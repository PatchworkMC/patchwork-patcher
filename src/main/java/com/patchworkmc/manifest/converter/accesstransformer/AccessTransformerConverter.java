package com.patchworkmc.manifest.converter.accesstransformer;

import org.apache.logging.log4j.Level;

import net.patchworkmc.manifest.accesstransformer.v2.ForgeAccessTransformer;
import net.patchworkmc.manifest.accesstransformer.v2.Transformed;
import net.patchworkmc.manifest.accesstransformer.v2.TransformedClass;
import net.patchworkmc.manifest.accesstransformer.v2.TransformedField;
import net.patchworkmc.manifest.accesstransformer.v2.TransformedMethod;
import net.patchworkmc.manifest.accesstransformer.v2.TransformedWildcardMember;
import net.patchworkmc.manifest.accesstransformer.v2.exception.MissingMappingException;
import net.patchworkmc.manifest.accesstransformer.v2.flags.AccessLevel;
import net.patchworkmc.manifest.accesstransformer.v2.flags.Finalization;

import com.patchworkmc.Patchwork;
import com.patchworkmc.mapping.MemberInfo;
import com.patchworkmc.mapping.MappingAssertions;

/**
 * Takes a {@link ForgeAccessTransformer} and spits out an AccessWidener/v1 file.
 */
public class AccessTransformerConverter {
	private AccessTransformerConverter() {
		// NO-OP
	}

	public static byte[] convertToWidener(ForgeAccessTransformer accessTransformer, MemberInfo info) {
		StringBuilder sb = new StringBuilder();
		sb.append("accessWidener\tv1\t").append("intermediary").append('\n');
		sb.append("#\tAutomatically generated by Patchwork Patcher.\n");
		sb.append("#\tThe original (but remapped) AT entry is roughly preserved here for debugging.\n");
		sb.append("#\tThey may be stripped in future releases.\n\n");

		for (TransformedClass targetClass : accessTransformer.getClasses()) {
			if (targetClass.getAccessLevel() != AccessLevel.KEEP || targetClass.getFinalization() != Finalization.KEEP) {
				writeClass(sb, targetClass);
			}

			try {
				writeWildcards(sb, targetClass.getName(), targetClass.getFieldWildcard(), targetClass.getMethodWildcard(), info);
			} catch (MissingMappingException ex) {
				Patchwork.LOGGER.throwing(Level.WARN, ex);
			}

			for (TransformedField field : targetClass.getFields()) {
				try {
					writeField(sb, field, info);
				} catch (MissingMappingException ex) {
					Patchwork.LOGGER.throwing(Level.WARN, ex);
				}
			}

			targetClass.getMethods().forEach(method -> writeMethod(sb, method));
		}

		return sb.toString().getBytes();
	}

	private static void writeClass(StringBuilder sb, TransformedClass targetClass) {
		// Modifier word
		sb.append(targetClass.getFinalization() == Finalization.REMOVE ? "extendable" : "accessible");
		// Target
		sb.append("\tclass\t").append(targetClass.getName()).append('\n');
	}

	private static void writeWildcards(StringBuilder sb, String owner, TransformedWildcardMember fields, TransformedWildcardMember methods,
				MemberInfo info) throws MissingMappingException {
		if (fields != null) {
			info.getMappings(owner).fields.forEach((key, field) -> writeField(sb, owner, field.name, field.descriptor, fields));
		}

		if (methods != null) {
			info.getMappings(owner).methods.forEach((key, method) -> writeMethod(sb, owner, method.name, method.descriptor, methods));
		}
	}

	private static void writeField(StringBuilder sb, TransformedField transformed, MemberInfo info) throws MissingMappingException {
		String owner = transformed.getOwner();
		String name = transformed.getName();
		MemberInfo.Member targetMember = info.getMappings(owner).fields.get(name);
		MappingAssertions.assertFieldExists(targetMember, owner, name);

		AccessTransformerConverter.writeField(sb, owner, name, targetMember.descriptor, transformed);
	}

	private static void writeField(StringBuilder sb, String owner, String name, String descriptor, Transformed transformed) {
		sb.append(transformed.getFinalization() == Finalization.REMOVE ? "mutable\t" : "accessible\t");

		sb.append("field\t").append(owner).append('\t');
		sb.append(name).append('\t').append(descriptor).append('\n');
	}

	private static void writeMethod(StringBuilder sb, TransformedMethod method) {
		writeMethod(sb, method.getOwner(), method.getName(), method.getDescriptor(), method);
	}

	private static void writeMethod(StringBuilder sb, String owner, String name, String descriptor, Transformed transformed) {
		// We go ahead and remove final unless it's explictly added because accessible on a method adds it.
		// This might cause a "desync" between the two in finalization status, but it shouldn't cause any issues.
		sb.append("extendable\t");
		sb.append("method\t").append(owner).append('\t');
		sb.append(name).append('\t').append(descriptor).append('\n');

		if (transformed.getAccessLevel().equals(AccessLevel.PUBLIC)) {
			sb.append("accessible\t");
			sb.append("method\t").append(owner).append('\t');
			sb.append(name).append('\t').append(descriptor).append('\n');
		}
	}
}
